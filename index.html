
<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI Companion Chat</title>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', sans-serif;
        }
        .font-orbitron {
            font-family: 'Orbitron', sans-serif;
        }
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .animate-fade-in-up {
            animation: fadeInUp 0.5s ease-out forwards;
        }
        .scrollbar-thin {
            scrollbar-width: thin;
            scrollbar-color: #334155 #1e293b;
        }
        .scrollbar-thin::-webkit-scrollbar {
            width: 8px;
        }
        .scrollbar-thin::-webkit-scrollbar-track {
            background: #1e293b;
        }
        .scrollbar-thin::-webkit-scrollbar-thumb {
            background-color: #334155;
            border-radius: 4px;
            border: 2px solid #1e293b;
        }
        .modal-enter {
            opacity: 0;
        }
        .modal-enter-active {
            opacity: 1;
            transition: opacity 300ms;
        }
        .modal-exit {
            opacity: 1;
        }
        .modal-exit-active {
            opacity: 0;
            transition: opacity 300ms;
        }
        .modal-content-enter {
            transform: scale(0.9) translateY(-10px);
            opacity: 0;
        }
        .modal-content-enter-active {
            transform: scale(1) translateY(0);
            opacity: 1;
            transition: all 300ms;
        }
        .modal-content-exit {
            transform: scale(1) translateY(0);
            opacity: 1;
        }
        .modal-content-exit-active {
            transform: scale(0.9) translateY(-10px);
            opacity: 0;
            transition: all 300ms;
        }
    </style>
<script type="importmap">
{
  "imports": {
    "react-dom/client": "https://esm.sh/react-dom/client",
    "react": "https://esm.sh/react",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.1.1/",
    "react/": "https://aistudiocdn.com/react@^19.1.1/"
  }
}
</script>
</head>
<body class="bg-slate-900 text-slate-200">
    <div id="root"></div>
    <script type="text/babel" data-type="module">
import React, { useState, useEffect, useRef, useCallback } from 'react';
import ReactDOM from 'react-dom/client';

// --- TYPES & CONSTANTS ---
const Role = {
  User: 'user',
  AI: 'assistant',
};

const API_ENDPOINT = "https://networking-entertainment-southampton-transmission.trycloudflare.com/v1/chat/completions";
const MODEL_NAME = "dolphin-2.9.4-llama3.1-8b@q8_0";
const LOCAL_STORAGE_KEY = 'ai-companion-chats';

// --- UTILITY FUNCTIONS ---
const stripEmojis = (str) => {
    if (!str) return '';
    // This regex removes most common emojis and symbols.
    const emojiRegex = /[\u{1F600}-\u{1F64F}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{1F1E0}-\u{1F1FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}\u{1F900}-\u{1F9FF}\u{1F018}-\u{1F270}\u{238C}]/gu;
    return str.replace(emojiRegex, '').trim();
};

// --- ICON COMPONENTS ---
const LoadingSpinner = () => (
  <svg className="animate-spin h-5 w-5 text-fuchsia-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
  </svg>
);
const MicIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M7 4a3 3 0 016 0v6a3 3 0 11-6 0V4z" /><path d="M5.5 10.5a.5.5 0 01.5.5v1a4 4 0 004 4h.5a.5.5 0 010 1h-.5a5 5 0 01-5-5v-1a.5.5 0 01.5-.5z" /><path d="M10 15a4 4 0 004-4v-1.5a.5.5 0 011 0V11a5 5 0 01-5 5h-1a.5.5 0 010-1h1z" /></svg>);
const SendIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z" /></svg>);
const SpeakerIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M6.99 7.5a.75.75 0 011.02-.72l5.03 2.51a.75.75 0 010 1.44l-5.03 2.51a.75.75 0 01-1.02-.72V7.5z" /><path d="M3 8.75A1.75 1.75 0 014.75 7h.5A1.75 1.75 0 017 8.75v2.5A1.75 1.75 0 015.25 13h-.5A1.75 1.75 0 013 11.25v-2.5z" /><path d="M12.5 6.168a.75.75 0 01.998-.445c1.455.57 2.502 1.93 2.502 3.445s-1.047 2.875-2.502 3.445a.75.75 0 01-.998-.94c1.15-.455 1.952-1.528 1.952-2.505s-.802-2.05-1.952-2.505a.75.75 0 01-.445-.998z" /></svg>);
const LibraryIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M8 14v3m4-3v3m4-3v3M3 21h18M3 10h18M3 7l9-4 9 4M4 10h16v11H4V10z" /></svg>);
const PlusIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M12 4v16m8-8H4" /></svg>);
const DownloadIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>);
const UploadIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>);
const TrashIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>);
const CloseIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>);
const EditIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828z" /><path fillRule="evenodd" d="M2 6a2 2 0 012-2h4a1 1 0 010 2H4v10h10v-4a1 1 0 112 0v4a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" clipRule="evenodd" /></svg>);
const RegenerateIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M10 3a1 1 0 011 1v1.337a6.002 6.002 0 11-2.05 11.127.75.75 0 01-1.25-1.25A4.5 4.5 0 1010 5.5V7a1 1 0 11-2 0V4a1 1 0 011-1z" clipRule="evenodd" /><path d="M12.24 3.76a.75.75 0 011.06 0l2.25 2.25a.75.75 0 010 1.06l-2.25 2.25a.75.75 0 01-1.06-1.06L13.94 6.5l-1.7-1.7a.75.75 0 010-1.04z" /></svg>);

// --- UI COMPONENTS ---

const ChatMessage = React.memo(({ message, isLastAIMessage, onRegenerate, isLoading }) => {
    const isUser = message.role === Role.User;
    
    const UserIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-cyan-400" viewBox="0 0 24 24" fill="currentColor"><path fillRule="evenodd" d="M18.685 19.097A9.723 9.723 0 0021.75 12c0-5.385-4.365-9.75-9.75-9.75S2.25 6.615 2.25 12a9.723 9.723 0 003.065 7.097A9.716 9.716 0 0012 21.75a9.716 9.716 0 006.685-2.653zm-12.54-1.285A7.486 7.486 0 0112 15a7.486 7.486 0 015.855 2.812A8.224 8.224 0 0112 20.25a8.224 8.224 0 01-5.855-2.438zM15.75 9a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0z" clipRule="evenodd" /></svg>);
    const AIIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-fuchsia-400" viewBox="0 0 24 24" fill="currentColor"><path fillRule="evenodd" d="M9.75 21.75H14.25c.414 0 .75-.336.75-.75V16.5c0-.414-.336-.75-.75-.75H9.75c-.414 0-.75.336-.75.75v4.5c0 .414.336.75.75.75zM10.5 17.25h3v3h-3v-3zM15 6.75a.75.75 0 01.75.75v2.25a.75.75 0 01-1.5 0V7.5a.75.75 0 01.75-.75zM8.25 7.5a.75.75 0 00-1.5 0v2.25a.75.75 0 001.5 0V7.5zM12 2.25A1.5 1.5 0 0113.5 3.75v.75a.75.75 0 001.5 0v-.75A3 3 0 0012 2.25a3 3 0 00-3 3v.75a.75.75 0 001.5 0v-.75A1.5 1.5 0 0112 2.25z" clipRule="evenodd" /><path d="M6.31 9.47a.75.75 0 01-1.06-1.06l1.5-1.5a.75.75 0 011.06 1.06l-1.5 1.5zm12.44 0a.75.75 0 001.06-1.06l-1.5-1.5a.75.75 0 00-1.06 1.06l1.5 1.5zM12 7.5a4.5 4.5 0 00-4.5 4.5v1.5a.75.75 0 001.5 0v-1.5a3 3 0 013-3 3 3 0 013 3v1.5a.75.75 0 001.5 0v-1.5A4.5 4.5 0 0012 7.5z" /></svg>);

    const wrapperClasses = isUser ? 'flex items-start gap-3 justify-end' : 'flex items-start gap-3 justify-start group';
    const bubbleClasses = isUser ? 'bg-cyan-900/50 border border-cyan-500/30 rounded-lg p-3 max-w-md text-cyan-50' : 'bg-slate-800 rounded-lg p-3 max-w-md text-slate-300';
    const iconWrapperClasses = `w-8 h-8 rounded-full flex-shrink-0 flex items-center justify-center ring-2 ${isUser ? 'bg-slate-700 ring-cyan-500/50' : 'bg-slate-700 ring-fuchsia-500/50'}`;
    const Icon = isUser ? UserIcon : AIIcon;

    return (
        <div className={`${wrapperClasses} animate-fade-in-up`}>
            {!isUser && (<div className={iconWrapperClasses}><Icon /></div>)}
            <div className={`flex flex-col ${isUser ? 'items-end' : 'items-start'}`}>
                <div className={bubbleClasses}><p className="whitespace-pre-wrap">{message.content}</p></div>
                <span className="text-xs text-slate-500 mt-1 px-1">{message.timestamp}</span>
            </div>
            {isUser && (<div className={iconWrapperClasses}><Icon /></div>)}

            {isLastAIMessage && !isLoading && message.content && (
                <button 
                    onClick={onRegenerate} 
                    className="self-center ml-2 p-1.5 rounded-full text-slate-400 hover:bg-slate-700 hover:text-cyan-400 opacity-0 group-hover:opacity-100 transition-opacity focus:outline-none focus:ring-2 focus:ring-cyan-500"
                    aria-label="Regenerate response"
                >
                    <RegenerateIcon />
                </button>
            )}
        </div>
    );
});

const VoiceControls = ({ voices, selectedVoice, onVoiceChange, autoRead, onAutoReadChange, onReadLast }) => (
    <div className="flex flex-wrap items-center justify-center gap-4 p-2 bg-slate-800/50 rounded-lg">
        <div className="flex items-center gap-2">
            <label htmlFor="voiceSelect" className="text-sm text-slate-400">Voice:</label>
            <select id="voiceSelect" value={selectedVoice} onChange={(e) => onVoiceChange(e.target.value)} className="bg-slate-700 border border-slate-600 rounded-md p-1.5 text-sm text-slate-200 focus:ring-2 focus:ring-fuchsia-500 focus:outline-none">
                {voices.map(voice => (<option key={voice.name} value={voice.name}>{voice.name} ({voice.lang})</option>))}
            </select>
        </div>
        <div className="flex items-center gap-2">
            <label className="flex items-center gap-2 cursor-pointer text-sm text-slate-400">
                <input type="checkbox" checked={autoRead} onChange={(e) => onAutoReadChange(e.target.checked)} className="w-4 h-4 rounded bg-slate-700 border-slate-600 text-cyan-500 focus:ring-cyan-500" />
                Auto-Read Replies
            </label>
        </div>
        <button onClick={onReadLast} className="flex items-center gap-2 bg-slate-700 hover:bg-slate-600 text-slate-300 px-3 py-1.5 rounded-md text-sm transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-cyan-500" aria-label="Read last AI reply">
            <SpeakerIcon /> Read Last
        </button>
    </div>
);

const ChatInput = ({ onSendMessage, isLoading, isListening, onMicClick }) => {
    const [inputValue, setInputValue] = useState('');
    const textareaRef = useRef(null);

    const handleSubmit = (e) => {
        e.preventDefault();
        if (!inputValue.trim()) return;
        onSendMessage(inputValue);
        setInputValue('');
    };

    const handleKeyDown = (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            handleSubmit(e);
        }
    };
    
    useEffect(() => {
        const textarea = textareaRef.current;
        if (textarea) {
            textarea.style.height = 'auto';
            const scrollHeight = textarea.scrollHeight;
            textarea.style.height = `${scrollHeight}px`;
            textarea.style.overflowY = scrollHeight > 200 ? 'scroll' : 'hidden';
        }
    }, [inputValue]);

    useEffect(() => {
        // When loading finishes, focus the input.
        if (!isLoading) {
            textareaRef.current?.focus();
        }
    }, [isLoading]);


    return (
        <form onSubmit={handleSubmit} className="flex items-end gap-2 bg-slate-800 p-2 rounded-lg border border-slate-700 focus-within:ring-2 focus-within:ring-cyan-500 transition-shadow duration-300">
            <textarea
                ref={textareaRef}
                value={inputValue}
                onChange={(e) => setInputValue(e.target.value)}
                onKeyDown={handleKeyDown}
                placeholder="Type your message or use the microphone..."
                className="flex-1 bg-transparent p-2 outline-none resize-none text-slate-200 placeholder-slate-500 scrollbar-thin scrollbar-thumb-slate-600 scrollbar-track-transparent"
                rows={1}
                disabled={isLoading}
                style={{maxHeight: '200px'}}
            />
            <div className="flex flex-col gap-2">
                <button type="button" onClick={onMicClick} disabled={isLoading} className={`p-2 rounded-full transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-fuchsia-500 ${isListening ? 'bg-red-500 animate-pulse text-white' : 'bg-slate-700 hover:bg-fuchsia-600 text-fuchsia-300'} disabled:opacity-50 disabled:cursor-not-allowed`} aria-label="Use Microphone"><MicIcon /></button>
                <button type="submit" disabled={isLoading || !inputValue.trim()} className="p-2 rounded-full bg-slate-700 hover:bg-cyan-600 text-cyan-300 transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed focus:outline-none focus:ring-2 focus:ring-cyan-500" aria-label="Send Message"><SendIcon /></button>
            </div>
        </form>
    );
};

const LibraryModal = ({ isOpen, onClose, chats, activeChatId, onNewChat, onSwitchChat, onDeleteChat, onExportChat, onImportChat, onRenameChat }) => {
    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 p-4 modal-enter modal-enter-active" onClick={onClose}>
            <div className="bg-slate-800 border border-slate-700 rounded-lg shadow-2xl w-full max-w-2xl max-h-[80vh] flex flex-col modal-content-enter modal-content-enter-active" onClick={e => e.stopPropagation()}>
                <header className="flex items-center justify-between p-4 border-b border-slate-700">
                    <h2 className="text-xl font-orbitron text-cyan-400">Chat Library</h2>
                    <button onClick={onClose} className="p-1 rounded-full text-slate-400 hover:bg-slate-700 hover:text-white transition-colors"><CloseIcon /></button>
                </header>
                
                <div className="flex items-center justify-between p-4 bg-slate-900/50 border-b border-slate-700 gap-2 flex-wrap">
                    <button onClick={onNewChat} className="flex items-center gap-2 bg-cyan-600 hover:bg-cyan-500 text-white px-3 py-2 rounded-md text-sm transition-colors duration-200"><PlusIcon /> New Chat</button>
                    <div className="flex gap-2">
                         <button onClick={() => onExportChat(activeChatId)} className="flex items-center gap-2 bg-slate-700 hover:bg-slate-600 text-slate-300 px-3 py-2 rounded-md text-sm transition-colors duration-200"><DownloadIcon /> Export Current</button>
                         <button onClick={onImportChat} className="flex items-center gap-2 bg-slate-700 hover:bg-slate-600 text-slate-300 px-3 py-2 rounded-md text-sm transition-colors duration-200"><UploadIcon /> Import Chat</button>
                    </div>
                </div>

                <div className="flex-1 overflow-y-auto p-4 scrollbar-thin">
                    <ul className="space-y-2">
                        {Object.values(chats).sort((a, b) => b.createdAt - a.createdAt).map(chat => (
                            <li key={chat.id} className={`flex items-center justify-between p-3 rounded-lg transition-colors duration-200 group ${chat.id === activeChatId ? 'bg-cyan-900/50' : 'bg-slate-700/50 hover:bg-slate-700'}`}>
                                <button onClick={() => onSwitchChat(chat.id)} className="flex-1 text-left truncate">
                                    <p className="font-medium text-slate-200">{chat.name}</p>
                                    <p className="text-xs text-slate-400">{chat.messages.length} messages - {new Date(chat.createdAt).toLocaleString()}</p>
                                </button>
                                <div className="flex items-center gap-2 pl-2">
                                     <button onClick={() => { const newName = prompt("Enter new chat name:", chat.name); if (newName) onRenameChat(chat.id, newName); }} className="p-2 rounded-full text-slate-400 hover:bg-slate-600 hover:text-cyan-400 opacity-0 group-hover:opacity-100 transition-opacity"><EditIcon/></button>
                                     <button onClick={(e) => { e.stopPropagation(); if (confirm('Are you sure you want to delete this chat?')) onDeleteChat(chat.id); }} className="p-2 rounded-full text-slate-400 hover:bg-slate-600 hover:text-red-500 opacity-0 group-hover:opacity-100 transition-opacity"><TrashIcon /></button>
                                </div>
                            </li>
                        ))}
                    </ul>
                </div>
            </div>
        </div>
    );
};


// --- MAIN APP COMPONENT ---
const App = () => {
    const [chats, setChats] = useState({});
    const [activeChatId, setActiveChatId] = useState(null);
    const [isLoading, setIsLoading] = useState(false);
    const [isListening, setIsListening] = useState(false);
    const [voices, setVoices] = useState([]);
    const [selectedVoice, setSelectedVoice] = useState('');
    const [autoRead, setAutoRead] = useState(true);
    const [isLibraryOpen, setIsLibraryOpen] = useState(false);
    
    const chatContainerRef = useRef(null);

    // --- CHAT & DATA MANAGEMENT ---
    useEffect(() => {
        try {
            const savedData = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY));
            if (savedData && savedData.chats && Object.keys(savedData.chats).length > 0 && savedData.activeChatId) {
                setChats(savedData.chats);
                setActiveChatId(savedData.activeChatId);
            } else {
                handleNewChat();
            }
        } catch (error) {
            console.error("Failed to load chats from localStorage", error);
            handleNewChat();
        }
    }, []);

    useEffect(() => {
        if (Object.keys(chats).length > 0 && activeChatId) {
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify({ chats, activeChatId }));
        }
    }, [chats, activeChatId]);

    const handleNewChat = () => {
        const newId = `chat-${Date.now()}`;
        const newChat = {
            id: newId,
            name: "New Conversation",
            messages: [],
            createdAt: Date.now()
        };
        setChats(prev => ({ ...prev, [newId]: newChat }));
        setActiveChatId(newId);
        setIsLibraryOpen(false);
    };

    const handleSwitchChat = (id) => {
        if (chats[id]) {
            setActiveChatId(id);
            setIsLibraryOpen(false);
        }
    };
    
    const handleDeleteChat = (idToDelete) => {
        if (Object.keys(chats).length <= 1) {
            alert("Cannot delete the last chat.");
            return;
        }
        setChats(prev => {
            const newChats = { ...prev };
            delete newChats[idToDelete];
            return newChats;
        });
        if (activeChatId === idToDelete) {
            const remainingChatIds = Object.keys(chats).filter(id => id !== idToDelete);
            setActiveChatId(remainingChatIds[0] || null);
        }
    };

    const handleRenameChat = (chatId, newName) => {
        setChats(prev => ({
            ...prev,
            [chatId]: { ...prev[chatId], name: newName }
        }));
    };
    
    const handleExportChat = (chatId) => {
        const chatToExport = chats[chatId];
        if (!chatToExport) {
            alert("Active chat not found for export.");
            return;
        }
        const blob = new Blob([JSON.stringify(chatToExport, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const safeName = chatToExport.name.replace(/[^a-z0-9]/gi, '_').toLowerCase();
        a.download = `chat-${safeName}-${chatToExport.id}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    };
    
    const handleImportChat = () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json,application/json';
        input.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const importedChat = JSON.parse(event.target.result);
                    if (importedChat.id && importedChat.name && Array.isArray(importedChat.messages)) {
                         const newId = `imported-${importedChat.id}-${Date.now()}`;
                         const newChat = { ...importedChat, id: newId, createdAt: Date.now() };
                         setChats(prev => ({ ...prev, [newId]: newChat }));
                         setActiveChatId(newId);
                         setIsLibraryOpen(false);
                         alert("Chat imported successfully!");
                    } else {
                        throw new Error("Invalid chat file format.");
                    }
                } catch (error) {
                    alert(`Failed to import chat: ${error.message}`);
                }
            };
            reader.readAsText(file);
        };
        input.click();
    };

    // --- VOICE & SPEECH ---
    const loadVoices = useCallback(() => {
        const availableVoices = window.speechSynthesis.getVoices();
        if (availableVoices.length > 0) {
            setVoices(availableVoices);
            const defaultVoice = availableVoices.find(v => v.lang.startsWith('en') && v.default) || availableVoices.find(v => v.lang.startsWith('en')) || availableVoices[0];
            if(defaultVoice) setSelectedVoice(defaultVoice.name);
        }
    }, []);

    useEffect(() => {
        loadVoices();
        window.speechSynthesis.onvoiceschanged = loadVoices;
    }, [loadVoices]);

    useEffect(() => {
        chatContainerRef.current?.scrollTo({ top: chatContainerRef.current.scrollHeight, behavior: 'smooth' });
    }, [chats, activeChatId]);

    const speak = useCallback((text) => {
        const textToSpeak = stripEmojis(text);
        if (!textToSpeak) return;
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(textToSpeak);
        const voice = voices.find(v => v.name === selectedVoice);
        if (voice) utterance.voice = voice;
        window.speechSynthesis.speak(utterance);
    }, [voices, selectedVoice]);

    const callApiAndStreamResponse = async (conversationHistory) => {
        try {
            const res = await fetch(API_ENDPOINT, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ model: MODEL_NAME, messages: conversationHistory, max_tokens: 1024, stream: true })
            });

            if (!res.ok) throw new Error(`API error: ${res.statusText}`);

            if (res.body) {
                const reader = res.body.getReader();
                const decoder = new TextDecoder("utf-8");
                let buffer = "";
                let reply = "";

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    buffer += decoder.decode(value, { stream: true });
                    const parts = buffer.split("\n\n");
                    
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i].trim();
                        if (!part) continue;
                        const lines = part.split(/\r?\n/);
                        for (const line of lines) {
                            if (!line.startsWith("data:")) continue;
                            const payload = line.replace(/^data:\s*/, '');
                            if (payload === "[DONE]") break;
                            try {
                                const json = JSON.parse(payload);
                                const token = json?.choices?.[0]?.delta?.content || json?.choices?.[0]?.text;
                                if (token) {
                                    reply += token;
                                    setChats(prev => {
                                        const newChats = { ...prev };
                                        const messages = [...newChats[activeChatId].messages];
                                        messages[messages.length - 1] = { ...messages[messages.length - 1], content: reply, timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) };
                                        newChats[activeChatId] = { ...newChats[activeChatId], messages };
                                        return newChats;
                                    });
                                }
                            } catch (e) {
                                // Fallback for non-JSON tokens if needed
                            }
                        }
                    }
                    buffer = parts[parts.length - 1];
                }
                if (autoRead && reply) speak(reply);
            } else {
                const data = await res.json();
                const reply = data?.choices?.[0]?.message?.content || "Sorry, I couldn't get a response.";
                 setChats(prev => {
                    const newChats = { ...prev };
                    const messages = [...newChats[activeChatId].messages];
                    messages[messages.length - 1] = { ...messages[messages.length - 1], content: reply, timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) };
                    newChats[activeChatId] = { ...newChats[activeChatId], messages };
                    return newChats;
                });
                if (autoRead && reply) speak(reply);
            }
        } catch (err) {
            const errorMessage = `⚠️ Error: ${err.message}`;
            setChats(prev => {
                const newChats = { ...prev };
                const messages = [...newChats[activeChatId].messages];
                messages[messages.length - 1] = { ...messages[messages.length - 1], content: errorMessage, timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) };
                newChats[activeChatId] = { ...newChats[activeChatId], messages };
                return newChats;
            });
        } finally {
            setIsLoading(false);
        }
    };
    
    // --- SEND MESSAGE & API CALL ---
    const handleSendMessage = async (text) => {
        if (!text.trim() || isLoading) return;

        const userMessage = { role: Role.User, content: text, timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) };
        const currentMessages = chats[activeChatId]?.messages || [];
        const conversationHistory = [...currentMessages, userMessage].map(msg => ({ role: msg.role, content: msg.content }));

        setIsLoading(true);
        const placeholderAiMessage = { role: Role.AI, content: "", timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) };
        
        setChats(prev => {
            const newChats = { ...prev };
            const currentChat = newChats[activeChatId];
            const chatName = currentChat.messages.length === 0 ? text.substring(0, 30) : currentChat.name;
            newChats[activeChatId] = { 
                ...currentChat, 
                name: chatName, 
                messages: [...currentChat.messages, userMessage, placeholderAiMessage] 
            };
            return newChats;
        });
        
        await callApiAndStreamResponse(conversationHistory);
    };

    const handleRegenerateResponse = async () => {
        if (isLoading) return;

        const currentChat = chats[activeChatId];
        if (!currentChat || currentChat.messages.length < 2) return;
        
        const lastMessage = currentChat.messages[currentChat.messages.length - 1];
        if (lastMessage.role !== Role.AI) return;

        const conversationHistory = currentChat.messages.slice(0, -1).map(msg => ({ role: msg.role, content: msg.content }));
        
        setIsLoading(true);

        setChats(prev => {
            const newChats = { ...prev };
            const messages = [...newChats[activeChatId].messages];
            messages[messages.length - 1] = { ...messages[messages.length - 1], content: "", timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) };
            newChats[activeChatId] = { ...newChats[activeChatId], messages };
            return newChats;
        });
        
        await callApiAndStreamResponse(conversationHistory);
    };

    const handleMicClick = () => {
        const SpeechRecognition = window.webkitSpeechRecognition || window.SpeechRecognition;
        if (!SpeechRecognition) return alert("Speech recognition is not supported in this browser.");
        
        const recognition = new SpeechRecognition();
        recognition.lang = "en-US";
        recognition.interimResults = false;
        recognition.maxAlternatives = 1;
        recognition.onstart = () => setIsListening(true);
        recognition.onend = () => setIsListening(false);
        recognition.onerror = (event) => console.error("Speech recognition error:", event.error);
        recognition.onresult = (event) => handleSendMessage(event.results[0][0].transcript);
        recognition.start();
    };

    const handleReadLast = () => {
        const lastAiMessage = [...(chats[activeChatId]?.messages || [])].reverse().find(m => m.role === Role.AI);
        if (lastAiMessage) speak(lastAiMessage.content);
    };

    const currentMessages = chats[activeChatId]?.messages || [];

    return (
        <div className="flex flex-col h-screen bg-slate-900 text-slate-100 p-4 max-w-4xl mx-auto">
             <LibraryModal 
                isOpen={isLibraryOpen} 
                onClose={() => setIsLibraryOpen(false)} 
                chats={chats}
                activeChatId={activeChatId}
                onNewChat={handleNewChat}
                onSwitchChat={handleSwitchChat}
                onDeleteChat={handleDeleteChat}
                onExportChat={handleExportChat}
                onImportChat={handleImportChat}
                onRenameChat={handleRenameChat}
             />
            <header className="flex items-center justify-between text-center p-4 border-b border-cyan-500/20">
                <div className="w-10"></div> {/* Spacer */}
                <div className="flex-1">
                    <h1 className="text-4xl font-orbitron text-cyan-400 tracking-widest">AI COMPANION</h1>
                    <p className="text-slate-400 text-sm">Your Personal Conversational AI</p>
                </div>
                <button onClick={() => setIsLibraryOpen(true)} className="p-2 rounded-full text-cyan-400 hover:bg-slate-700 transition-colors" aria-label="Open chat library">
                    <LibraryIcon />
                </button>
            </header>

            <main ref={chatContainerRef} className="flex-1 overflow-y-auto p-4 my-4 space-y-6 scrollbar-thin">
                {currentMessages.map((msg, index) => 
                    <ChatMessage 
                        key={`${activeChatId}-${index}`} 
                        message={msg}
                        isLastAIMessage={msg.role === Role.AI && index === currentMessages.length - 1}
                        onRegenerate={handleRegenerateResponse}
                        isLoading={isLoading}
                    />
                )}
                {isLoading && currentMessages[currentMessages.length-1]?.content === "" && (
                    <div className="flex items-start gap-3 justify-start animate-fade-in-up">
                        <div className="w-8 h-8 rounded-full bg-slate-700 flex-shrink-0 flex items-center justify-center ring-2 ring-fuchsia-500/50"><LoadingSpinner /></div>
                        <div className="bg-slate-800 rounded-lg p-3 max-w-md animate-pulse"><span className="text-slate-400">Thinking...</span></div>
                    </div>
                )}
            </main>

            <footer className="space-y-4">
                <VoiceControls voices={voices} selectedVoice={selectedVoice} onVoiceChange={setSelectedVoice} autoRead={autoRead} onAutoReadChange={setAutoRead} onReadLast={handleReadLast} />
                <ChatInput onSendMessage={handleSendMessage} isLoading={isLoading} isListening={isListening} onMicClick={handleMicClick} />
            </footer>
        </div>
    );
};

// --- REACT ROOT RENDERING ---
const rootElement = document.getElementById('root');
if (!rootElement) throw new Error("Could not find root element to mount to");

const root = ReactDOM.createRoot(rootElement);
root.render(<React.StrictMode><App /></React.StrictMode>);

    </script>
</body>
</html>






